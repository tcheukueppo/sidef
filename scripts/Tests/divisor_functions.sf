#!/usr/bin/ruby

# Tests for various Number divisor functions.

var n = irand(3,10)!

var h = Hash(
    divisors => 'sigma',
    prime_divisors => 'prime_sigma',
    prime_power_divisors => 'prime_power_sigma',
    square_divisors => 'square_sigma',
    squarefree_divisors => 'squarefree_sigma',

    udivisors => 'usigma',
    prime_udivisors => 'prime_usigma',
    prime_power_udivisors => 'prime_power_usigma',
    square_udivisors => 'square_usigma',
    squarefree_udivisors => 'squarefree_usigma',
)

for k in (0..5) {
    h.each {|a,b|
        assert_eq(n.(a).sum {|d| d**k }, n.(b)(k), "#{a} != #{b} for n=#{n} and k=#{k}")
    }
}

with (10!) {|n|
    var D = n.divisors
    assert_eq(n.power_divisors,    D.grep{.is_power})
    assert_eq(n.power_divisors(1), D.grep{.is_power(1)})
    assert_eq(n.power_divisors(2), D.grep{.is_power(2)})
    assert_eq(n.power_divisors(3), D.grep{.is_power(3)})
    assert_eq(n.power_divisors(4), D.grep{.is_power(4)})
    assert_eq(n.power_divisors(5), D.grep{.is_power(5)})
    assert_eq(n.power_divisors(9), D.grep{.is_power(9)})
}

with (21!) {|n|
    var D = n.udivisors
    assert_eq(n.power_udivisors,    D.grep{.is_power})
    assert_eq(n.power_udivisors(1), D.grep{.is_power(1)})
    assert_eq(n.power_udivisors(2), D.grep{.is_power(2)})
    assert_eq(n.power_udivisors(3), D.grep{.is_power(3)})
    assert_eq(n.power_udivisors(4), D.grep{.is_power(4)})
    assert_eq(n.power_udivisors(5), D.grep{.is_power(5)})
    assert_eq(n.power_udivisors(9), D.grep{.is_power(9)})
}

for n in (0..50) {
    var D1 = n.divisors
    var D2 = n.udivisors

    assert_eq(n.power_divisors,    D1.grep { .is_power })
    assert_eq(n.power_divisors(1), D1.grep { .is_power(1) })
    assert_eq(n.power_divisors(2), D1.grep { .is_power(2) })
    assert_eq(n.power_divisors(3), D1.grep { .is_power(3) })

    assert_eq(n.power_udivisors,    D2.grep { .is_power })
    assert_eq(n.power_udivisors(1), D2.grep { .is_power(1) })
    assert_eq(n.power_udivisors(2), D2.grep { .is_power(2) })
    assert_eq(n.power_udivisors(3), D2.grep { .is_power(3) })
}

assert_eq(5040.sigma(-1), 5040.divisors.sum {|d| d**(-1) })
assert_eq( 10!.sigma(-2),  10!.divisors.sum {|d| d**(-2) })

do {

    var n = 5040
    var D = n.divisors

    for k in (0..4) {
        assert_eq(k.powerfree_divisors(n), D.grep{ .is_powerfree(k) })
    }
}

do {
    func udivs(n) {
        n.divisors.grep {|x| gcd(x, n/x) == 1 }
    }

    func gcud(n, m) {
        udivs(n) & udivs(m) -> max
    }

    func biudivs(n) {
        n.divisors.grep {|x| gcud(x,n/x) == 1 }
    }

    func a(n,k=1) {
        biudivs(n).sum { _**k }
    }

    func g(n, k=1) {
        n.factor_prod {|p,e|
            (p**(k*(e + 1)) - 1)/(p**k - 1) - (e.is_even ? p**(k*(e/2)) : 0)
        }
    }

    assert_eq(
        20.of { bsigma(_+1, 1) },
        20.of { g(_+1) }
    )

    assert_eq(
        20.of { bsigma(_+1, 2) },
        20.of { g(_+1, 2) }
    )

    assert_eq(
        20.of { bsigma(_+1, 3) },
        20.of { g(_+1, 3) }
    )

    assert_eq(
        20.of { .bsigma },
        20.of { a(_) },
    )

    assert_eq(
        20.of { .bsigma(2) },
        20.of { a(_, 2) },
    )

    assert_eq(
        20.of { .bsigma(3) },
        20.of { a(_, 3) },
    )

    assert_eq(
        20.of  { a(_, 0) }
        20.of  { .bsigma(0) }
    )
}

do {
    assert_eq(
        30.of { .nusigma },
        30.of {|n| n.divisors.grep {|d| gcd(d, n/d) != 1 }.sum }
    )

    assert_eq(
        10.of { .nusigma(0) },
        10.of { .nusigma0 },
    )

    assert_eq(
        30.of { .nusigma(0) },
        30.of {|n| n.divisors.count {|d| gcd(d, n/d) != 1 } }
    )
}

say "** Test passed!"
