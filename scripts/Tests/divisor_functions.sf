#!/usr/bin/ruby

# Tests for various Number divisor functions.

var n = irand(3,10)!

var h = Hash(
    divisors => 'sigma',
    prime_divisors => 'prime_sigma',
    prime_power_divisors => 'prime_power_sigma',
    square_divisors => 'square_sigma',
    squarefree_divisors => 'squarefree_sigma',

    udivisors => 'usigma',
    prime_udivisors => 'prime_usigma',
    prime_power_udivisors => 'prime_power_usigma',
    square_udivisors => 'square_usigma',
    squarefree_udivisors => 'squarefree_usigma',
)

for k in (0..5) {
    h.each {|a,b|
        assert_eq(n.(a).sum {|d| d**k }, n.(b)(k), "#{a} != #{b} for n=#{n} and k=#{k}")
    }
}

with (10!) {|n|
    var D = n.divisors
    assert_eq(n.power_divisors,    D.grep{.is_power})
    assert_eq(n.power_divisors(1), D.grep{.is_power(1)})
    assert_eq(n.power_divisors(2), D.grep{.is_power(2)})
    assert_eq(n.power_divisors(3), D.grep{.is_power(3)})
    assert_eq(n.power_divisors(4), D.grep{.is_power(4)})
    assert_eq(n.power_divisors(5), D.grep{.is_power(5)})
    assert_eq(n.power_divisors(9), D.grep{.is_power(9)})
}

with (21!) {|n|
    var D = n.udivisors
    assert_eq(n.power_udivisors,    D.grep{.is_power})
    assert_eq(n.power_udivisors(1), D.grep{.is_power(1)})
    assert_eq(n.power_udivisors(2), D.grep{.is_power(2)})
    assert_eq(n.power_udivisors(3), D.grep{.is_power(3)})
    assert_eq(n.power_udivisors(4), D.grep{.is_power(4)})
    assert_eq(n.power_udivisors(5), D.grep{.is_power(5)})
    assert_eq(n.power_udivisors(9), D.grep{.is_power(9)})
}

for n in (0..50) {
    var D1 = n.divisors
    var D2 = n.udivisors

    assert_eq(n.power_divisors,    D1.grep { .is_power })
    assert_eq(n.power_divisors(1), D1.grep { .is_power(1) })
    assert_eq(n.power_divisors(2), D1.grep { .is_power(2) })
    assert_eq(n.power_divisors(3), D1.grep { .is_power(3) })

    assert_eq(n.power_udivisors,    D2.grep { .is_power })
    assert_eq(n.power_udivisors(1), D2.grep { .is_power(1) })
    assert_eq(n.power_udivisors(2), D2.grep { .is_power(2) })
    assert_eq(n.power_udivisors(3), D2.grep { .is_power(3) })
}

assert_eq(5040.sigma(-1), 5040.divisors.sum {|d| d**(-1) })
assert_eq( 10!.sigma(-2),  10!.divisors.sum {|d| d**(-2) })

do {

    var n = 5040
    var D = n.divisors

    for k in (0..4) {
        assert_eq(k.powerfree_divisors(n), D.grep{ .is_powerfree(k) })
    }
}

do {    # bi-unitary divisors
    func udivs(n) {
        n.divisors.grep {|x| gcd(x, n/x) == 1 }
    }

    func gcud(n, m) {
        udivs(n) & udivs(m) -> max
    }

    func biudivs(n) {
        n.divisors.grep {|x| gcud(x,n/x) == 1 }
    }

    func a(n,k=1) {
        biudivs(n).sum { _**k }
    }

    func g(n, k=1) {
        n.factor_prod {|p,e|
            (p**(k*(e + 1)) - 1)/(p**k - 1) - (e.is_even ? p**(k*(e/2)) : 0)
        }
    }

    assert_eq(
        20.of { bsigma(_+1, 1) },
        20.of { g(_+1) }
    )

    assert_eq(
        20.of { bsigma(_+1, 2) },
        20.of { g(_+1, 2) }
    )

    assert_eq(
        20.of { bsigma(_+1, 3) },
        20.of { g(_+1, 3) }
    )

    assert_eq(
        20.of { .bsigma },
        20.of { a(_) },
    )

    assert_eq(
        20.of { .bsigma(2) },
        20.of { a(_, 2) },
    )

    assert_eq(
        20.of { .bsigma(3) },
        20.of { a(_, 3) },
    )

    assert_eq(
        20.of  { a(_, 0) }
        20.of  { .bsigma(0) }
    )
}

do {    # non-unitary divisors
    assert_eq(
        30.of { .nusigma },
        30.of {|n| n.divisors.grep {|d| gcd(d, n/d) != 1 }.sum }
    )

    assert_eq(
        10.of { .nusigma(0) },
        10.of { .nusigma0 },
    )

    assert_eq(
        30.of { .nusigma(0) },
        30.of {|n| n.divisors.count {|d| gcd(d, n/d) != 1 } }
    )
}

do {    # infinitary divisors

    func isidiv(d, n) {

        if (n % d != 0) {
            return false
        }

        n.prime_divisors.each {|p|

            var n2 = valuation(n, p).digits(2)
            var d2 = valuation(d, p).digits(2)

            for j in (0 .. d2.end) {
                if ((n2[j] == 0) && (d2[j] != 0)) {
                    return false
                }
            }
        }

        return true;
    }

    func idivisors(n) {
        n.divisors.grep{ isidiv(_, n) }
    }

    func a(n, k=1) {

        return 0 if (n == 0)

        n.factor_prod {|p,e|

            #~ e.digits(2).map_kv {|r,v|
                #~ (p**(2**r * (v+1) * k) - 1) / (p**(k * 2**r) - 1)
            #~ }.prod

            var prod = 1
            var r = 0

            do {
                if (e%2 == 1) {
                    #prod *= ((p**(2**(r+1) * k) - 1) / (p**(k * 2**r) - 1))
                    prod *= (p**(k * 2**r) + 1)
                }
                ++r
            } while (e >>= 1)

            prod
        }
    }

    assert_eq(
        30.of { a(_+1) },
        30.of { idivisors(_+1).sum }
    )

    assert_eq(
        30.of { a(_+1, 2) },
        30.of { idivisors(_+1).sum { _**2 } }
    )

    assert_eq(
        30.of { a(_+1, 3) },
        30.of { idivisors(_+1).sum { _**3 } }
    )

    assert_eq(
        30.of { .isigma0 },
        30.of { idivisors(_).len }
    )

    assert_eq(
        30.of { .isigma },
        30.of { a(_) },
    )

    assert_eq(
        30.of { .isigma(2) },
        30.of { a(_, 2) },
    )

    assert_eq(
        30.of { .isigma(3) },
        30.of { a(_, 3) },
    )
}

say "** Test passed!"
